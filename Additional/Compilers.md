**Компилятор**
- [Компилятор](#Compiler)
- [Интерпретатор](#Interpreter)
- [Метод раскрутки](#Vortex)
- [Кросс-транслятор](#CrossCompiler)
- [Виртуальная машина](#VirtualMachine)
- [Компиляция "на лету"](#JITCompiler)
- [Фазы компиляции](#Phases)


<a name="Compiler"></a>
# Компилятор
Задача транслятора (translator) сделать программу, написанную на некотором языке программирования, понятной компьютеру. Этого можно добиться одним из двух способов: компиляцией (compilation) или интерпретацией (interpretation). Программу, являющуюся входными данными транслятора, будем называть исходной программой (source program). 

Обычно язык, на котором написана исходная программа, - это язык высокого уровня (high-level language).
Компилятор (compiler) переводит исходную программу в эквивалентную программу на языке, понятном компьютеру, то есть на машинном языке. Мы будем называть программу, получающуюся в результате работы компилятора, целевой программой (target program). 

Процесс компиляции состоит из двух частей: анализа (analysis) и синтеза (synthesis).
Анализирующая часть компилятора разбивает исходную программу на составляющие ее элементы (конструкции языка – language constructions) и создает промежуточное представление исходной программы. Синтезирующая часть из промежуточного представления создает новую, целевую, программу. 


<a name="Interpreter"></a>
# Интерпретатор
В отличие от компилятора интерпретатор не создает никакой новой программы.
Входными данными интерпретатора является не только исходная программа, но и входные данные самой исходной программы.
Интерпретатор, так же, как и компилятор, анализирует программу на входном языке, cоздает промежуточное представление, а затем выполняет операции, содержащиеся в тексте этой программы. Например, интерпретатор может построить дерево разбора, а затем выполнить операции, которыми помечены узлы этого дерева. 

<img src="https://github.com/m4stodon/ios-guide/tree/master/Additional/Images/Iterpreter.png"/>

Интерпретация приводит к более гибкой и лучшей диагностике ошибок, чем компиляция. Поскольку исходная программа исполняется непосредственно, интерпретатор может включать хороший отладчик (debugger). Кроме того, интерпретатор может легко справиться с языками, позволяюшими создавать программы, некоторые характеристики которых например, размеры и типы переменных) могут зависеть от входных данных. Некоторые черты языков программирования таковы, что они не могут быть реализованы иначе, чем с использованием интерпретации.

Современная ситуация такова, что в трансляторах часто используются как элементы компиляции, так и интерпретации. 


<a name="Vortex"></a>
# Метод раскрутки
Компилятор – это весьма большая и сложная программа; на написание и отладку компилятора на языке ассемблера можно истратить слишком много времени. Для того, чтобы как-то справиться с этой проблемой, был придуман метод раскрутки, суть которого заключается в следующем.
Пусть есть компилятор KA: P→A, где P – некоторый язык более высокого уровня, чем язык ассемблера. Тогда напишем KP: L→A, а затем применим компилятор KA к компилятору KP, т.е. получим KA=KA(KP): L→A. Такая схема проиллюстрирована с помощью Т-диаграмм на слайде и называется раскруткой (bootstrapping1 ).

Описанная схема может быть использована при написании компилятора некоторого языка на нем самом. Пусть у нас есть компилятор некоторого подмножества S языка L в
язык A, написанный на языке A, KA: S→A. Тогда мы можем написать KL: L→A и получим новый компилятор KA = KA(KL). Мы используем это подмножество S для того, чтобы написать компилятор языка L в язык A, KS: L→A. Если теперь мы применим компилятор KA к программе KS, то получим KA=KA(KS): L→A.

Раскрутку можно использовать и в следующей ситуации. Пусть у нас есть недостаточно эффективный компилятор KA: L→A. Можно написать более эффективный компилятор KL: L→A, а затем применить раскрутку.


<a name="CrossCompiler"></a>
# Кросс-транслятор
Пусть у нас есть два компьютера: компьютер M с языком ассемблера A и компьютер M1 с языком ассемблера A1. Кроме того, предположим, что имеется компилятор KA1: P→A1, а сам компьютер M по каким-то причинам не доступен либо пока еще не существует компилятор KA: P→A. Нас интересует компилятор KA: L→A. В такой ситуации мы можем использовать M1 в качестве инструментальной машины и написать компилятор KP: L→A, который принято называть кросс-транслятором (cross-compiler). Как только машина M станет доступной, мы сможем перенести KP на M и "раскрутить" его с помощью KA. Понятно, что это решение достаточно трудоемко, поскольку могут возникнуть проблемы при переносе, например, из-за различий операционных систем.

Под переносимой (portable) программой понимается программа, которая может без перетрансляции выполняться на нескольких (по меньшей мере, на двух) платформах. В связи с этим возникает вопрос о переносимости объектных программ, создаваемых компилятором. Компиляторы, созданные по методикам, рассмотренным выше, порождают непереносимые (non-portable) объектные программы. Поскольку компилятор, в конечном итоге, является программой, то мы можем говорить и о переносимых компиляторах. Одним из способов получения переносимых объектных программ является генерация объектной программы на языке более высокого уровня, чем язык ассемблера. Такие компиляторы иногда называют конвертерами (converter). 


<a name="VirtualMachine"></a>
# Виртуальная машина
Другой способ получения переносимой (portable) объектной программы связан с использованием виртуальных машин (virtual machine). При таком подходе исходный язык транслируется в коды некоторой специально разработанной машины, которую никто не собирается реализовывать "в железе". Затем для каждой целевой платформы пишется интерпретатор виртуальной машины.

Понятно, что архитектура виртуальной машины должна быть разработана таким образом, чтобы конструкции исходного языка удобно отображались в систему команд и сама система команд не была слишком сложной. При выполнении этих условий можно достаточно быстро написать интерпретатор виртуальной машины. Одна из первых широко известных виртуальных машин была разработана в 70-х годах Н. Виртом при написании компилятора Pascal-P. Этот компилятор генерировал специальный код, названный P-кодом и представляющий собой последовательность инструкций гипотетической стековой машины. Сегодня идея виртуальных машин приобрела широкую известность благодаря языку Java, компиляторы которого обычно генерируют так называемый байт-код, т.е. объектный код, который представляет собой последовательность команд виртуальной Java-машины. 


<a name="JITCompiler"></a>
# Компиляция "на лету"
Основная неприятность, связанная с использованием виртуальных машин, заключается в том, что обычно время выполнения интерпретируемой программы значительно больше, чем время работы программы, оттранслированной в "родной" машинный код. Для того, чтобы увеличить скорость работы приложений, была разработана технология компиляции "на лету" (Just-In-Time compiling; иногда такой подход называют также динамической компиляцией). Идея заключается в том, что JIT-компилятор генерирует машинный код прямо в оперативной памяти, не сохраняя его. Это приводит к значительному увеличению скорости выполнения приложения.

Часто JIT-компилятор используется вместе с интерпретатором виртуальной машины.
Организовывается это следующим образом. Вначале сгенерированный байт-код поступает на вход интерпретатору виртуальной машины, которая его интерпретирует.
Одновременно с интерпретатором работает программа, которая вычисляет время интерпретации какого-то куска байт-кода, например, процедуры. Если оказывается, что время интерпретации некоторого куска кода достаточно большое, то вызывается JIT-компилятор, который транслирует его в "родные" машинные коды. Когда при выполнении приложения произойдет повторное обращение к этому куску кода, то он уже не будет интерпретироваться, а будет выполняться сгенерированный фрагмент
машинного кода.

Использование связки "компилятор+интерпретатор+JIT-компилятор" позволяет заметно повысить скорость выполнения исходной программы, причем переносимость кода, создаваемого компилятором, естественно, сохраняется. 


<a name="Phases"></a>
# Фазы компиляции
Процесс создания компилятора можно свести к решению нескольких задач, которые
принято называть фазами компиляции (compilation phases). Обычно компилятор состоит
из следующих фаз:
* лексический анализ
* синтаксический анализ
* семантический анализ (проверка типов)
* оптимизация (константные вычисления, уменьшение силы операций, выделение общих подвыражений, чистка циклов и т.д. )
* генерация кода. 